name: Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
      custom_version:
        description: 'Custom version (e.g., 1.2.3) - required if type is custom'
        required: false
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
      draft:
        description: 'Create as draft release'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  packages: write

jobs:
  # =================================================================
  # Job 1: Version, Build, and Tag
  # =================================================================
  release:
    name: 🚀 Version and Build
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      timestamp: ${{ steps.build_info.outputs.timestamp }}
      artifact-name: ${{ steps.build_info.outputs.artifact-name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: 'npm'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Install dependencies
        run: npm ci

      - name: Create Release and Next Snapshot Version
        id: version
        run: |
          # --- 1. Determine and commit the release version ---
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          CUSTOM_VERSION="${{ github.event.inputs.custom_version }}"
          if [[ "$VERSION_TYPE" == "custom" ]]; then
            if [ -z "$CUSTOM_VERSION" ]; then
              echo "Error: A custom version must be provided." && exit 1
            fi
            npm version --no-git-tag-version "$CUSTOM_VERSION"
          else
            npm version --no-git-tag-version "$VERSION_TYPE"
          fi
          RELEASE_VERSION=$(node -p "require('./package.json').version")
          TAG="v$RELEASE_VERSION"
          echo "Release version: $RELEASE_VERSION"
          git add package.json package-lock.json
          git commit -m "chore(release): version $RELEASE_VERSION"

          # --- 2. Determine and commit the next snapshot version ---
          # First, bump the version to the next patch without creating a snapshot
          npm version --no-git-tag-version patch
          # Then, manually append -SNAPSHOT to that new version
          NEXT_VERSION=$(node -p "require('./package.json').version")
          SNAPSHOT_VERSION="$NEXT_VERSION-SNAPSHOT"
          # Use npm version again to set the final snapshot version string
          npm version --no-git-tag-version "$SNAPSHOT_VERSION"

          echo "Next snapshot version: $SNAPSHOT_VERSION"
          git add package.json package-lock.json
          git commit -m "chore(release): prepare for next development iteration"

          # --- 3. Set outputs for subsequent jobs ---
          echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create and Push Tag on Release Commit
        run: |
          # The release commit is the one BEFORE the snapshot commit (HEAD~1)
          RELEASE_COMMIT_HASH=$(git rev-parse HEAD~1)
          TAG="${{ steps.version.outputs.tag }}"

          # Create the tag on the correct commit
          git tag -a "$TAG" -m "Release $TAG" "$RELEASE_COMMIT_HASH"

          # Push both commits and the release tag
          git push
          git push origin "$TAG"

      - name: Build production application from tag
        run: |
          echo "Checking out tag ${{ steps.version.outputs.tag }} to build artifact..."
          git checkout ${{ steps.version.outputs.tag }}
          echo "Running npm ci for the release version..."
          npm ci
          echo "Building application..."
          npx ng build --configuration production

      - name: Prepare build information
        id: build_info
        run: |
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          ARTIFACT_NAME="porturl-frontend-${{ steps.version.outputs.tag }}.zip"
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "artifact-name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT

      - name: Archive production build
        run: |
          cd dist/porturl-frontend
          zip -r ../../${{ steps.build_info.outputs.artifact-name }} .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: ${{ steps.build_info.outputs.artifact-name }}
          retention-days: 7

  # =================================================================
  # Job 2: Build and Push Docker Image
  # =================================================================
  docker:
    name: 🐳 Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: release
    steps:
      - name: Checkout release tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release.outputs.tag }}

      - name: Set up QEMU & Docker Buildx
        uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare Docker tags
        id: docker_tags
        run: |
          IMAGE_NAME="friesoft/porturl-frontend"
          VERSION="${{ needs.release.outputs.version }}"
          IS_PRERELEASE="${{ github.event.inputs.prerelease }}"

          TAGS="$IMAGE_NAME:$VERSION"

          if [ "$IS_PRERELEASE" != "true" ]; then
            TAGS="$TAGS,$IMAGE_NAME:latest"
            MAJOR_MINOR=$(echo "$VERSION" | cut -d. -f1,2)
            TAGS="$TAGS,$IMAGE_NAME:$MAJOR_MINOR"
          fi

          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "Docker tags: $TAGS"

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.docker_tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=porturl-frontend
            org.opencontainers.image.version=${{ needs.release.outputs.version }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ needs.release.outputs.timestamp }}

  # =================================================================
  # Job 3: Create GitHub Release
  # =================================================================
  github-release:
    name: 📦 Create GitHub Release
    runs-on: ubuntu-latest
    needs: [release, docker]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Download build artifact
        uses: actions/download-artifact@v5
        with:
          name: build-artifact
          path: .

      - name: Get previous tag
        id: previous_tag
        run: |
          # List all tags, sort them correctly as versions, and get the one just before the current release tag.
          # This is more reliable than 'git describe' which can pick up the 'snapshot' tag.
          PREVIOUS_TAG=$(git tag | sort -V | grep -B 1 "${{ needs.release.outputs.tag }}" | head -n 1 || echo "")
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT

      - name: Generate changelog for release body
        uses: orhun/git-cliff-action@v4
        with:
          args: "${{ steps.previous_tag.outputs.previous_tag }}..${{ needs.release.outputs.tag }} --output release-notes.md"

      - name: Generate and prepend to cumulative changelog
        uses: orhun/git-cliff-action@v4
        with:
          args: "--prepend CHANGELOG.md ${{ steps.previous_tag.outputs.previous_tag }}..${{ needs.release.outputs.tag }}"

      - name: Commit CHANGELOG.md
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to CHANGELOG.md to commit."
          else
            git commit -m "docs(changelog): update for release ${{ needs.release.outputs.tag }}"
            git push
          fi

      - name: Read changelog file content
        id: changelog_content
        run: |
          echo 'changelog<<EOF' >> "$GITHUB_OUTPUT"
          cat release-notes.md >> "$GITHUB_OUTPUT"
          echo 'EOF' >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.release.outputs.tag }}
          name: "Release ${{ needs.release.outputs.tag }}"
          draft: ${{ github.event.inputs.draft == 'true' }}
          prerelease: ${{ github.event.inputs.prerelease == 'true' }}
          bodyFile: "release-notes.md"
          body: |
            ## 🚀 Release ${{ needs.release.outputs.version }}

            **Built:** `${{ needs.release.outputs.timestamp }}`

            **Compare with previous release:** [${{ steps.previous_tag.outputs.previous_tag }}...${{ needs.release.outputs.tag }}](https://github.com/${{ github.repository }}/compare/${{ steps.previous_tag.outputs.previous_tag }}...${{ needs.release.outputs.tag }})

            ### 🐳 Docker Image

            `docker pull friesoft/porturl-frontend:${{ needs.release.outputs.version }}`

            ---

            ${{ steps.changelog_content.outputs.changelog }}
          artifacts: "${{ needs.release.outputs.artifact-name }}"
          token: ${{ secrets.GITHUB_TOKEN }}
          makeLatest: ${{ github.event.inputs.prerelease != 'true' }}
